### 前言

一个和 CORS 相关的故事

故事的主角是一个求知若渴，希望获得各种资讯的小资，而政府想要监控这些求知若渴的人，试图知道他们到底都去问了哪些资讯，所以把他安置在一个小房间，跟外界的沟通都要通过门口的警卫。

所以小资没办法亲自出去，但是有什么想知道的事情都可以问警卫，警卫都会帮他去问。身为一个求知若渴的人，小资常常问他很多问题，例如：「奶茶店的奶茶现在多少钱一杯？」、「我的存款剩下多少？」、「我爸妈过得好吗」等等。

针对小资的每一个提问，警卫都会帮他去问到当事人，但不一定会把答案告诉他。政府规定了一个程序，那就是「除非被问的人明确同意，不然不能把答案告诉小资」，所以警卫会先问完问题拿到答案，再问说：「请问你愿意让小资知道这件事吗？」，有些人愿意，例如奶茶店，虽然他根本不认识小资，但毕竟这类资讯告诉谁都可以。但也有些人不愿意，因为根本不知道谁是小资。还有一种情况，警卫连问都不用问，那就是小资的家人。因为小资的家人跟小资血脉相承，系出同源，所以不用问就可以放行。

于是呢，尽管小资的每一个问题都有传达到被问的人那里，却不一定能收到回复。有一天小资终于受不了这种被囚禁的生活，于是想了几个方法。

- 第一个方法是把警卫打倒逃出去，没有警卫了他就自由了，想问谁问题就问谁，不用再通过警卫，完全没有任何拘束。

- 第二个方法是拜托朋友帮忙。每当小资有问题时，都跟警卫说：「你去问我朋友，奶茶多少钱」，接着朋友再去问奶茶店，再把结果跟警卫讲，顺便交代警卫他愿意让小资知道这件事。因为问题都会通过他朋友转达，而朋友每次都会交代警卫这个资讯可以让小资知道，所以小资就不会有之前提到的那个限制了。

- 第三个方法是让大家都愿意把资讯告诉他，这样就不会被警卫拦截，就能顺利知道问题的答案。


### 从熟悉的错误信息开始

```
request has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.
```
在前端用 XMLHttpRequest 或者是用 fetch 的时候，应该都有碰到过这个错误。在请求后端或是网络上的 API 时，就是访问不成功，而你也不知道是哪里出了错，甚至连这是前端还是后端要解决的可能都不太知道。

先说结论：
```
大部分情形下，CORS 都不是前端的问题，纯前端是解決不了的。
```
既然 CORS 的这个错误是出在「跨来源访问 API」，那就要理清楚两件事情：

1. 什么是跨来源？
2. 为什么不能跨来源访问 API？

### 什么是跨来源？

跨来源的英文是 cross origin，顾名思义，当你想要从来源 A 去拿来源 B 的东西，就是跨来源。

而这个来源，其实就是代表着「发送 request 的來源」，例如你现在在 https://huli.tw 发送一个 request 出去，那这个 request 的 origin 就是 https://huli.tw。

而 same origin 就代表着来源一样，如果有两个 URL A 跟 B 的 origin 是一样的，我们就说 A 跟 B 是 same origin，也叫做「同源（同个来源）」。

更精确一点地说，你可以把 origin 当作是：```scheme + host + port``` 的组合。scheme 就是最前面的那个 https 或是 http 之类的东西，host 就是 huli.tw，而 port 的话如果没有特別指定，http 预设的 port 就是 80，https 就是 443。

所以呢，

1. https://huli.tw 跟 https://huli.tw/api 同源，因为 scheme + host + port 都一样（/api 是 path 的部分，不是 host）

2. https://huli.tw 跟 http://huli.tw 不同源，因为 scheme 不一样

3. http://huli.tw 跟 http://huli.tw:3000 不同源，因为 port 不一样

4. https://api.huli.tw 跟 https://data.huli.tw 不同源，因为 host 不一样

5. https://huli.tw 跟 https://api.huli.tw 不同源，因为 host 不一样

第五点是大家要特别注意的一点，**domain 跟 subdomain 之间也是不同源的**，所以 api.huli.tw 跟 huli.tw 不同源。有很多人常常会把这个跟 cookie 搞混，因为 api.huli.tw 跟 huli.tw 是可以共用 cookie 的。

cookie 比对的规则叫做：[Domain Matching](https://tools.ietf.org/html/rfc6265#section-5.1.3)，它是看 domain 而不是看我们这边所说的 origin，千万不要搞混了。

从以上范例可以得知，其实要达成 same origin 蛮困难的，如果只看网址的话，基本上要长得一模一样，只有 path 跟后面的部分可以不一样，例如 https://huli.tw/a/b/c/index.html?a=1 跟 https://huli.tw/show/cool/b.html 他们都是在同一个 scheme + host + post 底下，origin 都是 https://huli.tw， 因此这两个网址是同源的。

在业务上面，其实也常会把前端网站本身跟 API 用不同的域来表示，例如 huli.tw 就是前端网站，api.huli.tw 就是后端 API，所以业务上也很常碰到跨来源请求的场景。

### 为什么不能跨来源访问 API？

理解了同源的定义之后，我们可以来看另一个问题，就是：「为什么不能跨来源访问 API？」。

但其实这个说法有点不清楚，更准确一点的说法是：「为什么不能用 XMLHttpRequest 或是 fetch（或也可以简单称作 AJAX）获取跨来源的资源？」

去拿一个「跨来源的资源」其实很常见，例如 <img src="https://another-domain.com/bg.png" />，这其实就是跨来源去抓取资源，只是这边我们抓取的目标是图片而已。

或者是：<script src="https://another-domain.com/script.js" />，这也是跨来源请求，去抓一个 JS 脚本回来并且执行。

但以上两种状况你有碰到过问题吗？基本上应该都没有，而且你已经用得很习惯了，完全没有想到可能会出问题。

那为什么变成 AJAX，变成用 XMLHttpRequest 或是 fetch 的时候就不同了？为什么这时候跨来源的请求就会被挡住？（这边的说法其实不太准确，之后会详细解释）

通过反证法，可以先思考下面这个问题：

```
如果跨来源请求不会被挡住，会发生什么事？
```

这样就有了安全性的问题，因为攻击者可以拿到一些机密资料。为什么要挡住跨来源的 AJAX，说穿了就是三个字：```安全性```

这时候有些人可能会有个疑问：「那为什么图片、CSS 或是 script 不挡？」

因为这些比较像是「网页资源的一部分」，例如我想要用别人的图片，我就用 <img> 来引入，想要用 CSS 就用 <link href="...">，这些标签可以拿到的资源是有限制的。再者，这些取回来的资源，我们没办法用程序去读取它，这很重要。

我载入图片之后它就真的只是张图片，只有浏览器知道图片的内容，我不会知道，我也没有办法用程序去读取它。既然没办法用程序去读取它，那我也没办法把拿到的结果传到其他地方，就比较不会有资料外泄的问题。

### 总结

1. 浏览器会挡你的跨来源请求，是因为安全性问题。因为 AJAX 你可以直接拿到整个 response，所以不挡的话会有安全问题，但像是 img 标签你其实就拿不到 response，所以比较没有问题

2. 今天会有 same-origin policy 跟 CORS，是因为我们「在浏览器上写 JS」，所以受到执行环境的限制。如果我们今天写的是 Node.js，就完全没有这些问题，想拿什么就拿什么，不会有人挡我们

3. **在浏览器上面，CORS 限制的其实是「拿不到 response」，而不是「发不出 request」**。所以 request 其实已经发出去了，浏览器也拿到 response 了，只是它因为安全性考量不给你（这个讲法也有一点不太精确，因为有分简单请求跟非简单请求）。
