## let 和 const 命令

### 1. 基本用法

- let 和 const 声明的变量只在其所在的代码块内有效

  ```
  {
    let a = 10;
    var b = 1;
  }
  a    // Uncaught ReferenceError: a is not defined
  b    // 1
  ```

因此 for 循环内的计数器就很适合使用 let 命令

  ```
  var a = [];
  for(var i=0; i<10; i++){
    a[i] = function(){
      console.log(i);
    }
  }
  a[6]();                // 10
  ```
  var 声明的变量 i 在全局范围内有效，全局只有一个变量 i，每一次循环，变量 i 的值都会变化，被赋给数组 a 的函数内部的 i 指向的是全局的 i。
  
  ```
  var a = [];
  for(let i=0; i<10; i++){
    a[i] = function(){
      console.log(i);
    }
  }
  a[6]();                // 6
  ```
  上面的代码中，变量 i 是用 let 声明的，当前的 i 只在本轮循环中有效。所以每次循环的 i 其实都是一个新的变量。
  
另外，for 循环还有一个特别之处，设置循环变量的那一部分是父作用域，而循环体内部是一个单独的子作用域。

  ```
  for(let i=0; i<3; i++){
    let i = 'abc';
    console.log(i);
  }
  ```
  // abc * 3
 
这表明函数体内部的变量 i 和循环变量 i 不在同一个作用域，而是有各自单独的作用域。

const 声明的是一个只读常量，一旦声明，常量的值就不能改变。

  ```
  const PI = 3.1415;
  PI = 3;              // Uncaught TypeError: Assignment to constant variable. 
  ```


- 不允许重复赋值

  ```
  // 报错
  function fn() {
    let a = 10;
    var a = 1;
  }
  ```

  ```
  // 报错 不能在函数内部重新声明参数
  function fn(arg) {
    let arg = 10;
  }
  ```
  
  
- 不存在变量提升  
  
  ```
  // var 的情况
  console.log(foo);      // undefined
  var foo = 2
  
  // let 的情况
  console.log(bar);      // Uncaught ReferenceError: bar is not defined
  let bar = 2
  ```
  
  变量 foo 用 var 声明会发生变量提升（脚本开始运行时，变量 foo 已经存在，但是没有值），let 声明变量不会变量提升，这表示在声明 bar 之前，变量 bar 是不存在的。
   
   
- 暂时性死区  
  
  
  
  
### 2. 块级作用域  





### 3. 顶层对象
  
  
