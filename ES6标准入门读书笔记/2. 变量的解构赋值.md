## 变量的解构赋值

ES6 允许按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构。本质上，这种写法属于 “模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 **解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转换为对象**。如果等号右边的是不可遍历的结构（转为对象后不具备 Iterator 接口 / 本身不具备 Iterator 接口），那么将会报错。

由于 undefined 和 null 无法转换为对象，所以对他们进行解构赋值时都会报错。

  ```
  let [foo] = 1;
  let [foo] = true; 
  let [foo] = undefined;     
  let [foo] = null;   
  let [foo] = NaN;
  let [foo] = null; 
  let [foo] = {}; 
  ```
  前 5 个是转为对象后不具备 Iterator 接口， 最后一个是本身不具备 Iterator 接口。

### 1. 字符串的解构赋值

字符串能解构赋值是因为 此时字符串被转换成了一个类似数组的对象。
  
  ```
  const [a,b,c,d,e] = 'hello';
  
  a     // 'h'
  b     // 'e'
  c     // 'l'
  d     // 'l'
  e     // 'o'
  ```

类似数组的对象都有一个 length 属性，因此还可以对这个属性进行解构赋值。

  ```
  let {length : len} = 'hello';
  len    // 5
  ```

### 2. 数值和布尔值的解构赋值

等号右边是数值或布尔值时，先转换成对象

  ```
  let {toString : s} = 123;
  s === Number.prototype.toString       // true
  
  let {toString : s} = true;
  s === Boolean.prototype.toString       // true
  ```

### 3. 数组的解构赋值

- 完全解构

  ```
  let [foo, [[bar], baz]] = [1, [[2], 3]];
  foo    // 1
  bar    // 2
  baz    // 3
  ```
  
  ```
  let [x, , y] = [1, 2, 3];
  x      // 1
  y      // 3
  ```
  
  ```
  let [head, ...tail] = [1, 2, 3, 4];
  head   // 1
  tail   // [2, 3, 4]
  ```

- 解构失败

  如果解构不成功，变量的值就等于 undefined。
  
  ```
  let [foo] = [];
  foo   // undefined
  ```
  
  ```
  let [x, y, ...z] = ['a'];
  x     // 'a'
  y     // undefined
  z     // []
  ```

- 不完全解构

即等号左边的模式只匹配一部分的等号右边的数组。

  ```
  let [a, [b], d] = [1, [2, 3], 4];
  a    // 1
  b    // 2
  d    // 4
  ```



#### 默认值












  
